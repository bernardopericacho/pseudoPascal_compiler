package vm;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Scanner;
import java.util.Stack;
import java.util.Vector;

import common.Instruction;

public class VirtualMachine {

	// ATRIBUTOS
	private static VirtualMachine vm = null;
	private static boolean trace;
	private static Vector<Object> dataMemory;
	private static ArrayList<Instruction> instructionMemory;
	private static Stack<Object> stack;
	private int pc;
	private static Vector<Boolean> modCells;

	// CONSTRUCTORAS
	private VirtualMachine() {
		trace = false;
		dataMemory = new Vector<Object>();
		stack = new Stack<Object>();
		pc = 0;
		modCells = new Vector<Boolean>();
	}

	// GETTERS Y SETTERS
	public static VirtualMachine getInstance() {
		if (vm == null)
			vm = new VirtualMachine();
		return vm;
	}

	public boolean isTrace() {
		return trace;
	}

	public void setTrace(boolean trace) {
		VirtualMachine.trace = trace;
	}

	public void setInstructionMemory(ArrayList<Instruction> im) {
		VirtualMachine.instructionMemory = im;
	}

	public void setPC(int pc) {
		this.pc = pc;
	}

	// METODOS PRIVADOS
	private void printCurrentInstruction() {
		if (pc >= instructionMemory.size())
			System.out.println("EJECUCION TERMINADA");
		else {
			System.out.print("Siguiente instruccion " + pc + ": ");
			System.out.println(instructionMemory.get(pc).toString());
		}
	}

	private void printDivision() {
		System.out.println();
		System.out.println("-------------------------------------------------");
		System.out.println();
	}

	private void printMemory() {
		System.out.println("Memoria");
		System.out.println("-------");
		System.out.println();
		Boolean tmpBool;
		for (int i = 0; i < modCells.size(); i++) {
			tmpBool = modCells.get(i);
			if ((tmpBool != null) && tmpBool) {
				System.out.print("M" + i + " ");
				System.out.println("[" + dataMemory.get(i).toString() + "]");
			}
			modCells.set(i, false);
		}
		System.out.println();
	}

	private void printStack() {
		System.out.println("Pila");
		System.out.println("----");
		System.out.println();
		Iterator<Object> it = stack.iterator();
		while (it.hasNext()) {
			System.out.print(it.next().toString() + " ");
		}
		printDivision();
	}

	// METODOS PUBLICOS
	public void exec() {

		getInstance();
		Scanner in = new Scanner(System.in);
		boolean end = (instructionMemory.size() == 0);

		if (trace) {
			printDivision();
			printCurrentInstruction();
		}

		try {
			while (!end) {
				if (trace) {
					String c = in.nextLine();
					if (c.compareToIgnoreCase("q") == 0) {
						System.out.println("EJECUCION ABORTADA");
						break;
					} else if (c.compareToIgnoreCase("c") == 0)
						trace = false;
				}
				instructionMemory.get(pc).exec();
				pc++;
				if (trace) {
					printDivision();
					printMemory();
					printStack();
					printCurrentInstruction();
				}
				if (pc > (instructionMemory.size() - 1))
					end = true;
			}
		} catch (Exception e) {
			printDivision();
			System.out.println("ERROR DURANTE LA EJECUCION");
			printDivision();
		}
		
		this.printStack();
		//this.printDivision();
		this.printMemory();
	}

	public void load(int dir) {
		stack.push(dataMemory.get(dir));
		//modCells.add(dir, true);
	}

	public Object pop() {
		return stack.pop();
	}

	public void push(Object o) {
		stack.push(o);
	}

	public void store(int dir, Object o) {
		//Object o = stack.pop();
		if (dataMemory.size() <= dir) {
			dataMemory.setSize(dir + 1);
			modCells.setSize(dir + 1);
		}
		dataMemory.set(dir, o);
		modCells.set(dir, true);
		//dataMemory.add(dir, o);
		//modCells.add(dir, true);
	}
	
	public void copy(int source, int target, int size) {
		if (dataMemory.size() < target + size) {
			dataMemory.setSize(target + size);
			modCells.setSize(target + size);
		}
		for(int i=0;i<size;i++) {
			dataMemory.set(target + i, dataMemory.get(source + i));	//.clone()
			modCells.set(target + i, true);
		}
	}

}